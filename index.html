<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Video Lab - VCR & VHS Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GIF generation library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        /* Requested Font: ThinDungGeunMo */
        @font-face {
            font-family: 'ThinRounded';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2511-1@1.0/ThinDungGeunMo.woff2') format('woff2');
            font-weight: normal;
            font-display: swap;
        }

        body {
            font-family: 'ThinRounded', 'VT323', 'Noto Sans KR', monospace;
            background-color: #050505;
            color: #d4d4d4;
        }

        /* Custom Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: #ec4899; /* Pink for VHS theme */
            margin-top: -6px;
            cursor: pointer;
            border: 2px solid #000;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
        }
        input[type=range]:focus {
            outline: none;
        }

        input[type=text] {
            font-family: 'ThinRounded', 'VT323', 'Noto Sans KR', monospace;
        }

        /* VCR Button Styling */
        .vcr-btn {
            background: linear-gradient(to bottom, #333, #111);
            border: 1px solid #444;
            box-shadow: inset 0 1px 0 #555, 0 2px 0 #000;
            transition: all 0.1s;
        }
        .vcr-btn:active {
            transform: translateY(2px);
            box-shadow: inset 0 2px 5px #000;
        }
        .vcr-btn.active {
            background: linear-gradient(to bottom, #004d00, #002200);
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: inset 0 0 10px #00ff00;
        }

        /* CRT Screen Effect Overlay for the UI */
        .crt-overlay::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-lg selection:bg-pink-900 selection:text-white">

    <!-- Header -->
    <header class="bg-zinc-900 border-b border-zinc-800 p-4 flex justify-between items-center shrink-0 z-10">
        <div class="flex items-center gap-2">
            <div class="w-4 h-4 bg-blue-600 rounded-sm animate-pulse border border-blue-400"></div>
            <h1 class="text-2xl text-pink-500 tracking-wider font-bold">RETRO VISION LAB v3.0 (VCR)</h1>
        </div>
        <div class="text-zinc-500 text-sm hidden sm:block">VHS / NTSC / VCR EMULATOR</div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col lg:flex-row h-full overflow-hidden relative">
        
        <!-- Left: Canvas Area -->
        <div class="flex-1 bg-black relative flex items-center justify-center p-4 overflow-hidden crt-overlay group">
            
            <div id="upload-placeholder" class="text-center z-10 pointer-events-none transition-opacity duration-300">
                <div class="w-full h-full absolute inset-0 bg-blue-800 flex items-center justify-center flex-col">
                    <p class="text-white text-4xl mb-2 font-bold animate-pulse">VIDEO CASSETTE RECORDER</p>
                    <p class="text-blue-200 text-xl">INSERT TAPE OR START CAMERA</p>
                </div>
            </div>

            <!-- The actual video element (hidden, used as source) -->
            <video id="source-video" loop muted playsinline crossorigin="anonymous" class="hidden"></video>
            
            <!-- The WebGL Canvas -->
            <canvas id="gl-canvas" class="max-w-full max-h-full shadow-2xl border-4 border-zinc-800 hidden bg-blue-800"></canvas>
            
            <!-- Recording Indicators -->
            <div id="recording-indicator-gif" class="hidden absolute top-8 right-8 flex items-center gap-2 bg-blue-900/80 text-white px-3 py-1 rounded border border-blue-500 z-20">
                <div class="w-3 h-3 bg-blue-400 rounded-full animate-pulse"></div>
                <span>GIF REC</span>
            </div>
            <div id="recording-indicator-video" class="hidden absolute top-8 right-8 flex items-center gap-2 bg-red-900/80 text-white px-3 py-1 rounded border border-red-500 z-20">
                <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                <span>VIDEO REC</span>
            </div>
        </div>

        <!-- Right: Controls -->
        <div class="w-full lg:w-96 bg-zinc-950 border-l border-zinc-800 flex flex-col shrink-0 h-[50vh] lg:h-auto z-10 shadow-xl">
            
            <!-- Source Input -->
            <div class="p-4 border-b border-zinc-800 bg-zinc-900/50 flex flex-col gap-2">
                <div class="flex justify-between items-center">
                    <div class="text-pink-400 text-sm mb-1">>> SOURCE INPUT</div>
                    <label class="flex items-center gap-2 text-xs cursor-pointer">
                        <input type="checkbox" id="toggle-vcr-osd" checked class="accent-green-500">
                        <span class="text-green-400">VCR OSD ÏºúÍ∏∞</span>
                    </label>
                </div>
                <div class="flex gap-2">
                    <label class="flex-1 cursor-pointer group">
                        <input type="file" id="video-input" accept="video/*" class="hidden">
                        <div class="vcr-btn text-center text-zinc-400 hover:text-white p-2 text-sm h-full flex items-center justify-center rounded">
                            üìº EJECT / LOAD
                        </div>
                    </label>
                    <button id="btn-camera" class="flex-1 vcr-btn text-center text-zinc-400 hover:text-white p-2 text-sm rounded">
                        ‚óâ CAMERA
                    </button>
                </div>
            </div>

            <!-- VCR Transport Controls -->
            <div class="p-4 border-b border-zinc-800 bg-black grid grid-cols-4 gap-2">
                <button id="btn-rew" class="vcr-btn p-2 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white">
                    <span>‚è™</span><span>REW</span>
                </button>
                <button id="btn-play" class="vcr-btn p-2 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white active">
                    <span>‚ñ∂</span><span>PLAY</span>
                </button>
                <button id="btn-pause" class="vcr-btn p-2 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white">
                    <span>‚è∏</span><span>PAUSE</span>
                </button>
                <button id="btn-ff" class="vcr-btn p-2 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white">
                    <span>‚è©</span><span>FF</span>
                </button>
            </div>

            <!-- Controls Scroll Area -->
            <div class="flex-1 overflow-y-auto no-scrollbar p-6 relative">
                
                <!-- Text Overlay Panel -->
                <div class="mb-8 pb-8 border-b border-zinc-800">
                    <div class="flex items-center justify-between text-green-500 border-b border-green-900/30 pb-2 mb-4">
                        <span class="text-sm">CUSTOM TEXT</span>
                        <span class="text-xs bg-green-900/20 px-2 py-0.5 rounded">TITLER</span>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <input type="text" id="text-input" placeholder="Ïª§Ïä§ÌÖÄ ÌÖçÏä§Ìä∏ ÏûÖÎ†•..." class="w-full bg-zinc-900 border border-zinc-700 p-2 text-white focus:border-green-500 focus:outline-none placeholder-zinc-600 font-mono text-sm" value="">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-xs text-zinc-500 block mb-1">ÏúÑÏπò X</label>
                                <input type="range" id="text-x" min="0" max="100" value="50" class="accent-green-500">
                            </div>
                            <div>
                                <label class="text-xs text-zinc-500 block mb-1">ÏúÑÏπò Y</label>
                                <input type="range" id="text-y" min="0" max="100" value="50" class="accent-green-500">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- VHS Panel -->
                <div class="space-y-6">
                    <div class="flex items-center justify-between text-pink-500 border-b border-pink-900/30 pb-2 mb-4">
                        <span class="text-sm">VIDEO TRACKING</span>
                        <span class="text-xs bg-pink-900/20 px-2 py-0.5 rounded">ADJUST</span>
                    </div>

                    <div class="space-y-5">
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÎÖ∏Ïù¥Ï¶à & ÎààÍΩÉ (Snow)</label>
                                <span id="val-noise">0.25</span>
                            </div>
                            <input type="range" id="param-noise" min="0" max="1" step="0.01" value="0.25">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>Ìó§Îìú Ïä§ÏúÑÏπ≠ & Ï∞¢ÍπÄ (Head)</label>
                                <span id="val-distortion">0.3</span>
                            </div>
                            <input type="range" id="param-distortion" min="0" max="1" step="0.01" value="0.30">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÏÉâ Î≤àÏßê (Chroma Bleed)</label>
                                <span id="val-rgbShift">3.5</span>
                            </div>
                            <input type="range" id="param-rgbShift" min="0" max="10" step="0.1" value="3.5">
                        </div>
                        
                        <div class="pt-4 border-t border-zinc-800 space-y-5">
                             <div class="group">
                                <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                    <label>ÌÖåÏù¥ÌîÑ ÎäòÏñ¥Ïßê (Wobble)</label>
                                    <span id="val-wobble">0.1</span>
                                </div>
                                <input type="range" id="param-wobble" min="0" max="1" step="0.01" value="0.1">
                            </div>
                            <div class="group">
                                <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                    <label>Ï†ÑÏõê ÎÖ∏Ïù¥Ï¶à (Hum)</label>
                                    <span id="val-hum">0.2</span>
                                </div>
                                <input type="range" id="param-hum" min="0" max="1" step="0.01" value="0.2">
                            </div>
                        </div>

                        <div class="pt-4 border-t border-zinc-800">
                             <div class="group">
                                <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                    <label>Ïä§Ï∫îÎùºÏù∏ (Scanlines)</label>
                                    <span id="val-scanline">0.4</span>
                                </div>
                                <input type="range" id="param-scanline" min="0" max="1" step="0.01" value="0.40">
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Export Section -->
            <div class="p-4 border-t border-zinc-800 bg-zinc-900 space-y-3">
                <div class="grid grid-cols-2 gap-2">
                    <button id="btn-record-gif" class="vcr-btn text-blue-400 py-3 text-sm font-bold tracking-wider rounded disabled:opacity-50">
                        GIF RECORD
                    </button>
                    <button id="btn-record-video" class="vcr-btn text-red-500 py-3 text-sm font-bold tracking-wider rounded disabled:opacity-50 flex justify-center items-center gap-2">
                        <span id="video-btn-text">‚óè TAPE REC</span>
                    </button>
                </div>
                <div id="status-msg" class="text-center text-xs text-zinc-500 h-4 font-mono"></div>
            </div>
        </div>
    </div>

    <!-- Hidden Download Link -->
    <a id="download-link" class="hidden"></a>

    <script>
        /**
         * Enhanced WebGL Shader Code for Realistic VHS/NTSC + VCR OSD
         */
        const vsSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fsSource = `
            precision mediump float;
            uniform sampler2D u_image;
            uniform sampler2D u_text;
            uniform float u_time;
            uniform int u_blueScreen; // 1 if blue screen active
            varying vec2 v_texCoord;

            // Params
            uniform float u_noise;      
            uniform float u_scanline;   
            uniform float u_rgbShift;   
            uniform float u_distortion; 
            uniform float u_wobble;     
            uniform float u_hum;        
            uniform float u_vignette;
            uniform float u_brightness;

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            vec3 rgb2yiq(vec3 c){
                return vec3(
                    0.299 * c.r + 0.587 * c.g + 0.114 * c.b,
                    0.596 * c.r - 0.275 * c.g - 0.321 * c.b,
                    0.212 * c.r - 0.523 * c.g + 0.311 * c.b
                );
            }

            vec3 yiq2rgb(vec3 c){
                return vec3(
                    1.0 * c.x + 0.956 * c.y + 0.621 * c.z,
                    1.0 * c.x - 0.272 * c.y - 0.647 * c.z,
                    1.0 * c.x - 1.105 * c.y + 1.702 * c.z
                );
            }

            void main() {
                vec2 uv = v_texCoord;
                
                // 1. Distortion & Wobble
                if (u_wobble > 0.0) {
                    uv.x += sin(uv.y * 10.0 + u_time) * 0.005 * u_wobble;
                    uv.x += cos(uv.y * 20.0 + u_time * 2.5) * 0.002 * u_wobble;
                }

                // Vertical Jitter
                float vJitter = 0.0;
                if (rand(vec2(u_time, u_time)) > 0.98) {
                    vJitter = (rand(vec2(u_time, 1.0)) - 0.5) * 0.05 * u_distortion;
                }
                uv.y += vJitter;

                // Horizontal Jitter (Tearing)
                float hShake = (rand(vec2(u_time, uv.y)) - 0.5) * 0.005 * u_distortion;
                hShake += sin(uv.y * 100.0 + u_time * 20.0) * 0.002 * u_distortion;
                
                // Head Switching (Bottom Tearing)
                if (uv.y < 0.05) {
                    float distortionStr = (0.05 - uv.y) * 20.0; 
                    hShake += sin(uv.y * 50.0 + u_time * 30.0) * 0.05 * distortionStr * u_distortion;
                    hShake += (rand(vec2(uv.y, u_time)) - 0.5) * 0.1 * distortionStr * u_distortion;
                }
                
                uv.x += hShake;

                // 2. Base Color (Video or Blue Screen)
                vec3 color;
                
                if (u_blueScreen == 1) {
                    // Classic VCR Blue
                    color = vec3(0.0, 0.0, 0.8); 
                } else {
                    // Video Sampling with NTSC Chroma Bleed
                    vec3 yiqCenter = rgb2yiq(texture2D(u_image, uv).rgb);
                    float bleed = u_rgbShift * 0.002;
                    vec3 yiqLeft = rgb2yiq(texture2D(u_image, uv - vec2(bleed, 0.0)).rgb);
                    vec3 yiqRight = rgb2yiq(texture2D(u_image, uv + vec2(bleed, 0.0)).rgb);
                    
                    vec3 finalYIQ;
                    finalYIQ.x = yiqCenter.x; 
                    float chromaBlurAmt = 0.4;
                    finalYIQ.y = mix(yiqCenter.y, (yiqLeft.y + yiqRight.y) * 0.5, chromaBlurAmt) * 1.2; 
                    finalYIQ.z = mix(yiqCenter.z, (yiqLeft.z + yiqRight.z) * 0.5, chromaBlurAmt) * 1.2; 
                    
                    color = yiq2rgb(finalYIQ);
                }

                // 3. Text Overlay (OSD)
                // Text jitter same as video for glued-on look
                vec4 texColor = texture2D(u_text, uv);
                color = mix(color, texColor.rgb, texColor.a);

                // 4. Artifacts (Applied to everything)
                // Scanlines
                float scanline = sin(uv.y * 600.0 + u_time * 10.0); 
                color -= u_scanline * 0.1 * (0.5 + 0.5 * scanline);

                // Noise
                float staticNoise = rand(uv + vec2(u_time, u_time));
                color += (staticNoise - 0.5) * u_noise * 0.5;

                // Dropouts
                if (rand(vec2(uv.y, u_time * 0.1)) > 0.995 && u_noise > 0.1) {
                    float streak = rand(vec2(uv.x, u_time));
                    color += vec3(streak) * u_noise * 2.0;
                }

                // Hum Bars
                if (u_hum > 0.0) {
                    float humWave = sin(uv.y * 2.0 + u_time * 5.0);
                    color += humWave * 0.1 * u_hum;
                }

                // Vignette & Brightness
                float dist = distance(uv, vec2(0.5, 0.5));
                color *= smoothstep(0.8, 0.8 - (u_vignette * 0.6), dist * (0.5 + u_vignette));
                color *= u_brightness;

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // === Application State ===
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        const video = document.getElementById('source-video');
        const placeholder = document.getElementById('upload-placeholder');
        const statusMsg = document.getElementById('status-msg');
        
        const params = {
            noise: 0.25,
            scanline: 0.4,
            rgbShift: 3.5,
            distortion: 0.3,
            wobble: 0.1,
            hum: 0.1,
            vignette: 0.5,
            brightness: 1.1
        };

        // VCR State
        let vcrState = {
            status: "STOP", // STOP, PLAY, PAUSE, FF, REW
            startTime: Date.now(),
            osdVisible: true,
            blueScreen: true,
            playbackRate: 1.0
        };

        const textParams = {
            customContent: "",
            x: 50,
            y: 50
        };

        let program, positionBuffer, texCoordBuffer, videoTexture, textTexture;
        let textCanvas, textCtx;
        let animationFrameId;

        // === Initialization ===
        function initWebGL() {
            if (!gl) return;

            textCanvas = document.createElement('canvas');
            textCtx = textCanvas.getContext('2d');

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            program = createProgram(gl, vertexShader, fragmentShader);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
            ]), gl.STATIC_DRAW);

            texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0,
            ]), gl.STATIC_DRAW);

            videoTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, videoTexture);
            setupTextureParams();

            textTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            setupTextureParams();
        }

        function setupTextureParams() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        // === VCR OSD Logic ===
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        function getVCRStatusText() {
            switch(vcrState.status) {
                case "PLAY": return "‚ñ∂ PLAY";
                case "PAUSE": return "|| PAUSE";
                case "FF": return "‚è© FF >>";
                case "REW": return "‚è™ REW <<";
                case "STOP": return "‚ñ† STOP";
                default: return "";
            }
        }

        function updateTextCanvas() {
            if (!textCanvas || !textCtx || !canvas.width) return;

            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.font = `40px "ThinRounded", "VT323", monospace`;
            textCtx.fillStyle = "#ffffff";
            textCtx.textBaseline = 'top';
            
            // Text Shadow (Black Outline for OSD)
            textCtx.shadowColor = "black";
            textCtx.shadowBlur = 0;
            textCtx.lineWidth = 3;
            textCtx.strokeStyle = "black";

            // 1. Draw VCR OSD (if enabled)
            if (vcrState.osdVisible) {
                const padding = 40;
                
                // Top Left: Status
                const statusText = getVCRStatusText();
                textCtx.strokeText(statusText, padding, padding);
                textCtx.fillText(statusText, padding, padding);

                // Top Right: Mode
                const modeText = "SP";
                const modeWidth = textCtx.measureText(modeText).width;
                textCtx.strokeText(modeText, textCanvas.width - padding - modeWidth, padding);
                textCtx.fillText(modeText, textCanvas.width - padding - modeWidth, padding);

                // Bottom Left: Date/Time (Fake)
                const now = new Date();
                const dateStr = `AM 12:00`; // Classic VCR stuck time or dynamic
                // Let's use real time for fun
                const realTime = now.toLocaleTimeString('en-US', {hour12: true, hour: '2-digit', minute:'2-digit'});
                textCtx.strokeText(realTime, padding, textCanvas.height - padding - 40);
                textCtx.fillText(realTime, padding, textCanvas.height - padding - 40);

                // Bottom Right: Counter
                let counterTime = 0;
                if (!video.paused) counterTime = video.currentTime;
                const timeStr = formatTime(counterTime);
                const timeWidth = textCtx.measureText(timeStr).width;
                textCtx.strokeText(timeStr, textCanvas.width - padding - timeWidth, textCanvas.height - padding - 40);
                textCtx.fillText(timeStr, textCanvas.width - padding - timeWidth, textCanvas.height - padding - 40);
            }

            // 2. Draw Custom Text
            if (textParams.customContent) {
                const x = (textParams.x / 100) * textCanvas.width;
                const y = (textParams.y / 100) * textCanvas.height;
                textCtx.font = `60px "ThinRounded", "VT323", monospace`;
                
                // Center align custom text
                const metrics = textCtx.measureText(textParams.customContent);
                textCtx.strokeText(textParams.customContent, x - metrics.width/2, y);
                textCtx.fillText(textParams.customContent, x - metrics.width/2, y);
            }

            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
        }

        // === Rendering Loop ===
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            
            // Default aspect if no video
            let aspect = 4/3; 
            if (video.videoWidth) {
                aspect = video.videoWidth / video.videoHeight;
            }

            let newW = containerW;
            let newH = containerW / aspect;

            if (newH > containerH) {
                newH = containerH;
                newW = containerH * aspect;
            }

            // Set canvas resolution high enough for text
            const resX = video.videoWidth || 640;
            const resY = video.videoHeight || 480;

            canvas.width = resX;
            canvas.height = resY;
            canvas.style.width = `${newW - 32}px`;
            canvas.style.height = `${newH - 32}px`;

            textCanvas.width = resX;
            textCanvas.height = resY;
            
            updateTextCanvas();
        }

        function render(time) {
            if (!program) return;
            
            gl.useProgram(program);

            // Determine what to show
            // If vcrState.blueScreen is true, we pass flag to shader
            // However, if we are playing, blueScreen is false.
            
            // Pass textures
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, videoTexture);
            // Only update texture if we have data
            if (video.readyState >= 2 && !vcrState.blueScreen) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            }
            gl.uniform1i(gl.getUniformLocation(program, "u_image"), 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.uniform1i(gl.getUniformLocation(program, "u_text"), 1);

            // Geometry
            const positionLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            gl.enableVertexAttribArray(texCoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Uniforms
            gl.uniform1f(gl.getUniformLocation(program, "u_time"), time * 0.001);
            gl.uniform1i(gl.getUniformLocation(program, "u_blueScreen"), vcrState.blueScreen ? 1 : 0);
            
            gl.uniform1f(gl.getUniformLocation(program, "u_noise"), parseFloat(params.noise));
            gl.uniform1f(gl.getUniformLocation(program, "u_scanline"), parseFloat(params.scanline));
            gl.uniform1f(gl.getUniformLocation(program, "u_rgbShift"), parseFloat(params.rgbShift));
            gl.uniform1f(gl.getUniformLocation(program, "u_distortion"), parseFloat(params.distortion));
            gl.uniform1f(gl.getUniformLocation(program, "u_wobble"), parseFloat(params.wobble));
            gl.uniform1f(gl.getUniformLocation(program, "u_hum"), parseFloat(params.hum));
            gl.uniform1f(gl.getUniformLocation(program, "u_vignette"), parseFloat(params.vignette));
            gl.uniform1f(gl.getUniformLocation(program, "u_brightness"), parseFloat(params.brightness));

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Update OSD continuously for time code
            updateTextCanvas();

            animationFrameId = requestAnimationFrame(render);
        }

        // === Logic & Interactions ===
        function setVCRState(status) {
            vcrState.status = status;
            
            // Reset Buttons
            document.querySelectorAll('.vcr-btn').forEach(b => b.classList.remove('active'));
            
            // Logic
            switch(status) {
                case "PLAY":
                    video.playbackRate = 1.0;
                    video.play();
                    vcrState.blueScreen = false;
                    document.getElementById('btn-play').classList.add('active');
                    break;
                case "PAUSE":
                    video.pause();
                    vcrState.blueScreen = false; // Pause shows still frame
                    document.getElementById('btn-pause').classList.add('active');
                    break;
                case "FF":
                    video.playbackRate = 3.0;
                    video.play();
                    vcrState.blueScreen = false;
                    document.getElementById('btn-ff').classList.add('active');
                    break;
                case "REW":
                    // Fake rewind: standard HTML5 video sucks at reverse playback
                    // We will set blue screen or just play very slowly to simulate struggle?
                    // Let's do a skip back loop
                    video.playbackRate = 1.0;
                    video.pause(); 
                    vcrState.blueScreen = false; // Show still
                    document.getElementById('btn-rew').classList.add('active');
                    rewindInterval = setInterval(() => {
                        video.currentTime = Math.max(0, video.currentTime - 0.5);
                    }, 100);
                    return; // Special case for interval
                case "STOP":
                    video.pause();
                    video.currentTime = 0;
                    vcrState.blueScreen = true;
                    // No button highlight for stop usually, or maybe all off
                    break;
            }

            // Clear rewind interval if not REW
            if (typeof rewindInterval !== 'undefined') clearInterval(rewindInterval);
        }
        let rewindInterval;

        function setupUI() {
            // VCR Buttons
            document.getElementById('btn-play').addEventListener('click', () => setVCRState("PLAY"));
            document.getElementById('btn-pause').addEventListener('click', () => setVCRState("PAUSE"));
            document.getElementById('btn-ff').addEventListener('click', () => setVCRState("FF"));
            document.getElementById('btn-rew').addEventListener('click', () => setVCRState("REW"));
            
            // OSD Toggle
            document.getElementById('toggle-vcr-osd').addEventListener('change', (e) => {
                vcrState.osdVisible = e.target.checked;
            });

            // File Upload
            document.getElementById('video-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    loadVideoSource(url);
                }
            });

            // Camera
            document.getElementById('btn-camera').addEventListener('click', async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 640, height: 480 },
                        audio: true 
                    });
                    video.srcObject = stream;
                    setVCRState("PLAY");
                    resizeCanvas();
                    placeholder.style.display = 'none';
                    canvas.classList.remove('hidden');
                } catch (err) {
                    alert("Ïπ¥Î©îÎùº Í∂åÌïú Ïò§Î•ò");
                }
            });

            // Sliders
            const bindSlider = (id, key, displayId) => {
                const el = document.getElementById(id);
                const display = document.getElementById(displayId || `val-${key}`);
                el.addEventListener('input', (e) => {
                    params[key] = e.target.value;
                    if(display) display.innerText = e.target.value;
                });
            };

            bindSlider('param-noise', 'noise');
            bindSlider('param-scanline', 'scanline');
            bindSlider('param-rgbShift', 'rgbShift');
            bindSlider('param-distortion', 'distortion');
            bindSlider('param-wobble', 'wobble');
            bindSlider('param-hum', 'hum');
            
            // Custom Text
            document.getElementById('text-input').addEventListener('input', (e) => {
                textParams.customContent = e.target.value;
            });
            document.getElementById('text-x').addEventListener('input', (e) => {
                textParams.x = e.target.value;
            });
            document.getElementById('text-y').addEventListener('input', (e) => {
                textParams.y = e.target.value;
            });
        }

        function loadVideoSource(src) {
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(t => t.stop());
                video.srcObject = null;
            }
            video.src = src;
            video.load();
            setVCRState("PLAY");
            placeholder.style.display = 'none';
            canvas.classList.remove('hidden');
            resizeCanvas();
        }

        // === Export Logic (Same as before) ===
        const workerBlob = new Blob([`importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');`], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        
        document.getElementById('btn-record-gif').addEventListener('click', () => {
            const btn = document.getElementById('btn-record-gif');
            const indicator = document.getElementById('recording-indicator-gif');
            if (btn.disabled) return;
            btn.disabled = true;
            indicator.classList.remove('hidden');
            statusMsg.innerText = "GIF ÎÖπÌôî Ï§ë...";

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: 320,
                height: 320 * (canvas.height / canvas.width),
                workerScript: workerUrl
            });

            const fps = 15;
            const duration = 3000;
            let framesCaptured = 0;
            const totalFrames = (duration / 1000) * fps;

            const interval = setInterval(() => {
                if (framesCaptured >= totalFrames) {
                    clearInterval(interval);
                    statusMsg.innerText = "GIF ÏÉùÏÑ± Ï§ë...";
                    gif.on('finished', (blob) => {
                        downloadBlob(blob, 'vcr_rec.gif');
                        btn.disabled = false;
                        indicator.classList.add('hidden');
                        statusMsg.innerText = "ÏôÑÎ£å!";
                    });
                    gif.render();
                } else {
                    gif.addFrame(canvas, {copy: true, delay: 1000/fps});
                    framesCaptured++;
                }
            }, 1000/fps);
        });

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.getElementById('download-link');
            a.href = url;
            a.download = filename;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        // Start
        initWebGL();
        setupUI();
        requestAnimationFrame(render);
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
