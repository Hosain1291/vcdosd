<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Video Lab - Real VHS Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        @font-face {
            font-family: 'ThinRounded';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2511-1@1.0/ThinDungGeunMo.woff2') format('woff2');
            font-weight: normal;
            font-display: swap;
        }

        body {
            font-family: 'ThinRounded', 'VT323', 'Noto Sans KR', monospace;
            background-color: #050505;
            color: #d4d4d4;
            overscroll-behavior: none;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            height: 24px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            background: #ec4899; 
            margin-top: -8px;
            cursor: pointer;
            border: 2px solid #000;
            border-radius: 50%;
        }
        
        /* Blue slider variant for export controls */
        input[type=range].slider-blue::-webkit-slider-thumb {
            background: #60a5fa; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }

        .vcr-btn {
            background: linear-gradient(to bottom, #333, #111);
            border: 1px solid #444;
            box-shadow: inset 0 1px 0 #555, 0 2px 0 #000;
            transition: all 0.1s;
        }
        .vcr-btn:active {
            transform: translateY(2px);
            box-shadow: inset 0 2px 5px #000;
        }
        .vcr-btn.active {
            background: linear-gradient(to bottom, #004d00, #002200);
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: inset 0 0 10px #00ff00;
        }

        .crt-overlay::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
    </style>
</head>
<body class="h-[100dvh] flex flex-col overflow-hidden text-base sm:text-lg selection:bg-pink-900 selection:text-white">

    <header class="bg-zinc-900 border-b border-zinc-800 p-3 sm:p-4 flex justify-between items-center shrink-0 z-10 h-14 sm:h-16">
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 sm:w-4 sm:h-4 bg-green-600 rounded-sm animate-pulse border border-green-400"></div>
            <h1 class="text-xl sm:text-2xl text-pink-500 tracking-wider font-bold truncate">REAL VHS LAB v4.2</h1>
        </div>
        <div class="text-zinc-500 text-xs sm:text-sm hidden sm:block">TRUE NTSC SIMULATION</div>
        <div class="sm:hidden text-zinc-600 text-xs border border-zinc-700 px-1 rounded">MOBILE</div>
    </header>

    <div class="flex-1 flex flex-col lg:flex-row h-full overflow-hidden relative">
        
        <div class="flex-1 bg-black relative flex items-center justify-center p-2 sm:p-4 overflow-hidden crt-overlay group min-h-[40%]">
            <div id="upload-placeholder" class="text-center z-10 pointer-events-none transition-opacity duration-300 w-full px-4">
                <div class="w-full aspect-video max-w-lg mx-auto bg-blue-800 flex items-center justify-center flex-col border-4 border-zinc-800 shadow-xl p-4">
                    <p class="text-white text-2xl sm:text-4xl mb-2 font-bold animate-pulse">VCR SYSTEM</p>
                    <p class="text-blue-200 text-sm sm:text-xl">INSERT TAPE / CAM</p>
                </div>
            </div>

            <video id="source-video" loop muted playsinline crossorigin="anonymous" class="hidden"></video>
            <canvas id="gl-canvas" class="max-w-full max-h-full shadow-2xl border-2 sm:border-4 border-zinc-800 hidden bg-blue-800"></canvas>
            
            <div id="recording-indicator-gif" class="hidden absolute top-4 right-4 sm:top-8 sm:right-8 flex items-center gap-2 bg-blue-900/80 text-white px-2 py-1 sm:px-3 sm:py-1 rounded border border-blue-500 z-20 text-xs sm:text-base">
                <div class="w-2 h-2 sm:w-3 sm:h-3 bg-blue-400 rounded-full animate-pulse"></div>
                <span>GIF</span>
            </div>
            <div id="recording-indicator-video" class="hidden absolute top-4 right-4 sm:top-8 sm:right-8 flex items-center gap-2 bg-red-900/80 text-white px-2 py-1 sm:px-3 sm:py-1 rounded border border-red-500 z-20 text-xs sm:text-base">
                <div class="w-2 h-2 sm:w-3 sm:h-3 bg-red-500 rounded-full animate-pulse"></div>
                <span>REC</span>
            </div>
        </div>

        <div class="w-full lg:w-96 bg-zinc-950 border-t lg:border-t-0 lg:border-l border-zinc-800 flex flex-col shrink-0 h-[50dvh] lg:h-auto z-10 shadow-[0_-5px_15px_rgba(0,0,0,0.5)]">
            
            <div class="p-3 sm:p-4 border-b border-zinc-800 bg-zinc-900/50 flex flex-col gap-2 shrink-0">
                <div class="flex justify-between items-center">
                    <div class="text-pink-400 text-xs sm:text-sm mb-1">>> SOURCE INPUT</div>
                    <label class="flex items-center gap-2 text-xs cursor-pointer active:opacity-70">
                        <input type="checkbox" id="toggle-vcr-osd" checked class="accent-green-500 w-4 h-4">
                        <span class="text-green-400">OSD ÏºúÍ∏∞</span>
                    </label>
                </div>
                <div class="flex gap-2">
                    <label class="flex-1 cursor-pointer group active:scale-95 transition-transform">
                        <input type="file" id="video-input" accept="video/*" class="hidden">
                        <div class="vcr-btn text-center text-zinc-400 hover:text-white p-2 sm:p-3 text-xs sm:text-sm h-full flex items-center justify-center rounded font-bold">
                            üìº LOAD FILE
                        </div>
                    </label>
                    <button id="btn-camera" class="flex-1 vcr-btn text-center text-zinc-400 hover:text-white p-2 sm:p-3 text-xs sm:text-sm rounded font-bold active:scale-95 transition-transform">
                        ‚óâ CAMERA
                    </button>
                </div>
            </div>

            <div class="p-2 sm:p-4 border-b border-zinc-800 bg-black grid grid-cols-4 gap-1 sm:gap-2 shrink-0">
                <button id="btn-rew" class="vcr-btn p-3 sm:p-4 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white touch-manipulation">
                    <span class="text-lg">‚è™</span>
                </button>
                <button id="btn-play" class="vcr-btn p-3 sm:p-4 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white active touch-manipulation">
                    <span class="text-lg">‚ñ∂</span>
                </button>
                <button id="btn-pause" class="vcr-btn p-3 sm:p-4 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white touch-manipulation">
                    <span class="text-lg">‚è∏</span>
                </button>
                <button id="btn-ff" class="vcr-btn p-3 sm:p-4 text-xs flex flex-col items-center justify-center gap-1 rounded text-zinc-400 hover:text-white touch-manipulation">
                    <span class="text-lg">‚è©</span>
                </button>
            </div>

            <div class="flex-1 overflow-y-auto no-scrollbar p-4 sm:p-6 relative">
                
                <div class="mb-6 pb-6 border-b border-zinc-800">
                    <div class="flex items-center justify-between text-green-500 border-b border-green-900/30 pb-2 mb-4">
                        <span class="text-sm">TITLER (ÏûêÎßâ)</span>
                        <span class="text-xs bg-green-900/20 px-2 py-0.5 rounded">EDIT</span>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <input type="text" id="text-input" placeholder="Ïª§Ïä§ÌÖÄ ÌÖçÏä§Ìä∏..." class="w-full bg-zinc-900 border border-zinc-700 p-2 text-white focus:border-green-500 focus:outline-none placeholder-zinc-600 font-mono text-sm rounded">
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="text-xs text-zinc-500 block mb-1">X Ï¢åÌëú</label>
                                <input type="range" id="text-x" min="0" max="100" value="50" class="accent-green-500">
                            </div>
                            <div>
                                <label class="text-xs text-zinc-500 block mb-1">Y Ï¢åÌëú</label>
                                <input type="range" id="text-y" min="0" max="100" value="50" class="accent-green-500">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="space-y-6 pb-20">
                    <div class="flex items-center justify-between text-pink-500 border-b border-pink-900/30 pb-2 mb-4">
                        <span class="text-sm">PRO TRACKING (ÌôîÏßà Ï°∞Ï†ï)</span>
                        <span class="text-xs bg-pink-900/20 px-2 py-0.5 rounded">V4.0 ENGINE</span>
                    </div>

                    <div class="space-y-6">
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÏÉâ Î≤àÏßê (Chroma Blur)</label>
                                <span id="val-rgbShift">4.5</span>
                            </div>
                            <input type="range" id="param-rgbShift" min="0" max="10" step="0.1" value="4.5">
                        </div>
                         <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÌÖåÎëêÎ¶¨ ÏûîÏÉÅ (Sharpen)</label>
                                <span id="val-sharpen">0.5</span>
                            </div>
                            <input type="range" id="param-sharpen" min="0" max="2" step="0.01" value="0.5">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÎÖ∏Ïù¥Ï¶à (Snow)</label>
                                <span id="val-noise">0.3</span>
                            </div>
                            <input type="range" id="param-noise" min="0" max="1" step="0.01" value="0.3">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>Ìó§Îìú Ï∞¢ÍπÄ (Head)</label>
                                <span id="val-distortion">0.2</span>
                            </div>
                            <input type="range" id="param-distortion" min="0" max="1" step="0.01" value="0.2">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>ÌôîÎ©¥ Ïö∏Î†ÅÏûÑ (Wobble)</label>
                                <span id="val-wobble">0.05</span>
                            </div>
                            <input type="range" id="param-wobble" min="0" max="1" step="0.01" value="0.05">
                        </div>
                        <div class="group">
                            <div class="flex justify-between mb-1 text-sm text-zinc-400 group-hover:text-pink-400 transition-colors">
                                <label>Ï†ÑÏõê ÎÖ∏Ïù¥Ï¶à (Hum)</label>
                                <span id="val-hum">0.15</span>
                            </div>
                            <input type="range" id="param-hum" min="0" max="1" step="0.01" value="0.15">
                        </div>
                    </div>
                </div>
            </div>

            <div class="p-3 sm:p-4 border-t border-zinc-800 bg-zinc-900 space-y-3 shrink-0 pb-safe">
                <!-- GIF Duration Slider -->
                <div class="flex justify-between items-center text-xs text-zinc-400 px-1">
                    <label>GIF ÎÖπÌôî ÏãúÍ∞Ñ: <span id="val-gif-duration" class="text-blue-400 text-sm font-bold">3.0</span>Ï¥à</label>
                    <input type="range" id="param-gif-duration" min="1.0" max="10.0" step="0.5" value="3.0" class="w-32 h-2 slider-blue bg-zinc-700 rounded-lg appearance-none cursor-pointer">
                </div>

                <div class="grid grid-cols-2 gap-2">
                    <button id="btn-record-gif" class="vcr-btn text-blue-400 py-3 sm:py-4 text-xs sm:text-sm font-bold tracking-wider rounded disabled:opacity-50 active:scale-95 transition-transform touch-manipulation">
                        GIF Ï†ÄÏû•
                    </button>
                    <button id="btn-record-video" class="vcr-btn text-red-500 py-3 sm:py-4 text-xs sm:text-sm font-bold tracking-wider rounded disabled:opacity-50 flex justify-center items-center gap-2 active:scale-95 transition-transform touch-manipulation">
                        <span id="video-btn-text">‚óè ÏòÅÏÉÅ Ï†ÄÏû•</span>
                    </button>
                </div>
                <div id="status-msg" class="text-center text-xs text-zinc-500 h-4 font-mono truncate"></div>
            </div>
        </div>
    </div>

    <a id="download-link" class="hidden"></a>

    <script>
        /**
         * REAL VHS/NTSC SHADER V4.0
         * Features: Chroma Subsampling, Edge Ringing (Peaking), YIQ Color Space, Interlacing Artifacts
         */
        const vsSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fsSource = `
            precision mediump float;
            uniform sampler2D u_image;
            uniform sampler2D u_text;
            uniform float u_time;
            uniform int u_blueScreen; 
            uniform vec2 u_resolution; // Added resolution for precise pixel ops

            varying vec2 v_texCoord;

            // Params
            uniform float u_noise;      
            uniform float u_scanline;   
            uniform float u_rgbShift;   // Chroma Blur Amount
            uniform float u_distortion; 
            uniform float u_wobble;     
            uniform float u_hum;        
            uniform float u_vignette;
            uniform float u_brightness;
            uniform float u_sharpen;    // New param: Edge Ringing

            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            // NTSC Standard YIQ Transform
            vec3 rgb2yiq(vec3 c){
                return vec3(
                    0.299 * c.r + 0.587 * c.g + 0.114 * c.b,
                    0.596 * c.r - 0.275 * c.g - 0.321 * c.b,
                    0.212 * c.r - 0.523 * c.g + 0.311 * c.b
                );
            }

            vec3 yiq2rgb(vec3 c){
                return vec3(
                    1.0 * c.x + 0.956 * c.y + 0.621 * c.z,
                    1.0 * c.x - 0.272 * c.y - 0.647 * c.z,
                    1.0 * c.x - 1.105 * c.y + 1.702 * c.z
                );
            }

            void main() {
                vec2 uv = v_texCoord;
                
                // --- 1. GEOMETRY & TIMING ---
                
                // Tape Wobble (Low freq wave)
                if (u_wobble > 0.0) {
                    uv.x += sin(uv.y * 10.0 + u_time) * 0.002 * u_wobble;
                    uv.x += cos(uv.y * 30.0 + u_time * 2.0) * 0.001 * u_wobble;
                }

                // H-Sync Jitter (High freq noise)
                float jitter = (rand(vec2(u_time, uv.y)) - 0.5) * 0.005 * u_distortion;
                // Add "Combing" effect (Interlacing simulation) on movement
                // We fake it by jittering odd/even lines differently
                if (mod(gl_FragCoord.y, 2.0) < 1.0) {
                    jitter *= 1.5; 
                }
                uv.x += jitter;

                // Head Switching (Bottom tearing)
                if (uv.y < 0.05) {
                    float distStr = (0.05 - uv.y) * 20.0;
                    uv.x += sin(uv.y * 100.0 + u_time * 20.0) * 0.05 * distStr * u_distortion;
                }

                // --- 2. COLOR & SIGNAL PROCESSING ---
                
                vec3 color;
                
                if (u_blueScreen == 1) {
                    color = vec3(0.0, 0.0, 0.8);
                    // Add static on blue screen
                    color += (rand(uv + u_time) - 0.5) * 0.2;
                } else {
                    // Sample Center
                    vec3 rgb = texture2D(u_image, uv).rgb;
                    vec3 yiq = rgb2yiq(rgb);
                    
                    // A. CHROMA SUBSAMPLING (The "VHS Look")
                    // VHS color bandwidth is terrible (~0.4 MHz). We simulate this by heavily blurring I and Q channels horizontally.
                    float blurWidth = u_rgbShift * 0.004; 
                    
                    vec3 yiqL = rgb2yiq(texture2D(u_image, uv + vec2(-blurWidth, 0.0)).rgb);
                    vec3 yiqR = rgb2yiq(texture2D(u_image, uv + vec2(blurWidth, 0.0)).rgb);
                    vec3 yiqL2 = rgb2yiq(texture2D(u_image, uv + vec2(-blurWidth * 2.5, 0.0)).rgb);
                    vec3 yiqR2 = rgb2yiq(texture2D(u_image, uv + vec2(blurWidth * 2.5, 0.0)).rgb);

                    // Average Chroma (I, Q) but KEEP Luma (Y) sharp
                    float i_blur = (yiqL.y + yiqR.y + yiqL2.y + yiqR2.y + yiq.y) / 5.0;
                    float q_blur = (yiqL.z + yiqR.z + yiqL2.z + yiqR2.z + yiq.z) / 5.0;
                    
                    // Reassemble
                    vec3 finalYIQ = vec3(yiq.x, i_blur, q_blur);
                    
                    // B. LUMA SHARPENING (Edge Ringing/Peaking)
                    // VCRs artificially boost sharpness, causing white halos around black lines.
                    if (u_sharpen > 0.0) {
                        float lumaLeft = rgb2yiq(texture2D(u_image, uv + vec2(-0.002, 0.0)).rgb).x;
                        float lumaRight = rgb2yiq(texture2D(u_image, uv + vec2(0.002, 0.0)).rgb).x;
                        // High pass = Center - Average
                        float highPass = finalYIQ.x - (lumaLeft + lumaRight) * 0.5;
                        // Add back to sharpen
                        finalYIQ.x += highPass * u_sharpen * 3.0; 
                    }

                    color = yiq2rgb(finalYIQ);
                }

                // --- 3. ARTIFACTS & OVERLAYS ---

                // Text Overlay (Jitter with video)
                vec4 texColor = texture2D(u_text, uv);
                color = mix(color, texColor.rgb, texColor.a);

                // Scanlines (Moving slightly)
                float scanline = sin(uv.y * u_resolution.y * 0.5 + u_time * 5.0);
                color -= 0.05 * u_scanline * (1.0 + scanline);

                // Noise (Grain) - Luminance noise
                float n = rand(uv + vec2(u_time * 10.0, u_time));
                color += (n - 0.5) * u_noise * 0.4;
                
                // Dropouts (White streaks)
                if (u_noise > 0.2 && rand(vec2(uv.y, u_time)) > 0.99) {
                     float streak = rand(vec2(uv.x * 0.1, u_time)); // stretched noise
                     if (streak > 0.5) color += vec3(0.6);
                }

                // Hum Bars (60Hz ground loop)
                if (u_hum > 0.0) {
                    float hum = sin(uv.y * 4.0 + u_time * 8.0);
                    // AC beat causes geometric distortion too
                    // already handled in UV, here just add darkness bar
                    color -= hum * 0.1 * u_hum;
                    // And a slight magenta tint
                    color.g -= hum * 0.05 * u_hum;
                }

                // Vignette
                float dist = distance(uv, vec2(0.5, 0.5));
                color *= smoothstep(0.8, 0.8 - (u_vignette * 0.6), dist * (0.5 + u_vignette));

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
        const video = document.getElementById('source-video');
        const placeholder = document.getElementById('upload-placeholder');
        const statusMsg = document.getElementById('status-msg');
        
        // Defaults tuned for realism
        const params = {
            noise: 0.3,
            scanline: 0.5,
            rgbShift: 4.5, // High chroma blur for VHS feel
            distortion: 0.2,
            wobble: 0.05,
            hum: 0.15,
            vignette: 0.4,
            sharpen: 0.5, // New default
            brightness: 1.0
        };

        // Added GIF Duration default
        let gifDuration = 3000;

        let vcrState = {
            status: "STOP",
            osdVisible: true,
            blueScreen: true
        };

        const textParams = {
            customContent: "",
            x: 50,
            y: 50
        };

        let program, positionBuffer, texCoordBuffer, videoTexture, textTexture;
        let textCanvas, textCtx;
        let animationFrameId;

        function initWebGL() {
            if (!gl) return;

            textCanvas = document.createElement('canvas');
            textCtx = textCanvas.getContext('2d');

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            program = createProgram(gl, vertexShader, fragmentShader);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");

            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
            ]), gl.STATIC_DRAW);

            texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0,
            ]), gl.STATIC_DRAW);

            videoTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, videoTexture);
            setupTextureParams();

            textTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            setupTextureParams();
        }

        function setupTextureParams() {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return null;
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        function getVCRStatusText() {
            switch(vcrState.status) {
                case "PLAY": return "‚ñ∂ PLAY";
                case "PAUSE": return "|| PAUSE";
                case "FF": return "‚è© FF >>";
                case "REW": return "‚è™ REW <<";
                case "STOP": return "‚ñ† STOP";
                default: return "";
            }
        }

        function updateTextCanvas() {
            if (!textCanvas || !textCtx || !canvas.width) return;

            textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);
            textCtx.font = `40px "ThinRounded", "VT323", monospace`;
            textCtx.fillStyle = "#ffffff";
            textCtx.textBaseline = 'top';
            textCtx.shadowColor = "black";
            textCtx.shadowBlur = 0;
            textCtx.lineWidth = 4;
            textCtx.strokeStyle = "black";
            
            // Smoother scaling for text
            const scale = canvas.width / 640; 
            const fontSize = Math.max(20, 40 * scale);
            textCtx.font = `${fontSize}px "ThinRounded", "VT323", monospace`;

            if (vcrState.osdVisible) {
                const padding = 40 * scale;
                const statusText = getVCRStatusText();
                
                // Status
                textCtx.strokeText(statusText, padding, padding);
                textCtx.fillText(statusText, padding, padding);

                // Mode
                const modeText = "SP";
                const modeWidth = textCtx.measureText(modeText).width;
                textCtx.strokeText(modeText, textCanvas.width - padding - modeWidth, padding);
                textCtx.fillText(modeText, textCanvas.width - padding - modeWidth, padding);

                // Date
                const now = new Date();
                const realTime = now.toLocaleTimeString('en-US', {hour12: true, hour: '2-digit', minute:'2-digit'});
                textCtx.strokeText(realTime, padding, textCanvas.height - padding - fontSize);
                textCtx.fillText(realTime, padding, textCanvas.height - padding - fontSize);

                // Counter
                let counterTime = !video.paused ? video.currentTime : 0;
                const timeStr = formatTime(counterTime);
                const timeWidth = textCtx.measureText(timeStr).width;
                textCtx.strokeText(timeStr, textCanvas.width - padding - timeWidth, textCanvas.height - padding - fontSize);
                textCtx.fillText(timeStr, textCanvas.width - padding - timeWidth, textCanvas.height - padding - fontSize);
            }

            if (textParams.customContent) {
                const x = (textParams.x / 100) * textCanvas.width;
                const y = (textParams.y / 100) * textCanvas.height;
                // Bigger custom text
                textCtx.font = `${fontSize * 1.5}px "ThinRounded", "VT323", monospace`;
                const metrics = textCtx.measureText(textParams.customContent);
                textCtx.strokeText(textParams.customContent, x - metrics.width/2, y);
                textCtx.fillText(textParams.customContent, x - metrics.width/2, y);
            }

            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            
            let aspect = 4/3; 
            if (video.videoWidth) aspect = video.videoWidth / video.videoHeight;

            let newW = containerW;
            let newH = containerW / aspect;

            if (newH > containerH) {
                newH = containerH;
                newW = containerH * aspect;
            }

            const resX = video.videoWidth || 640;
            const resY = video.videoHeight || 480;

            canvas.width = resX;
            canvas.height = resY;
            
            canvas.style.width = `${newW - 20}px`; 
            canvas.style.height = `${newH - 20}px`;

            textCanvas.width = resX;
            textCanvas.height = resY;
            
            updateTextCanvas();
        }

        function render(time) {
            if (!program) return;
            gl.useProgram(program);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, videoTexture);
            if (video.readyState >= 2 && !vcrState.blueScreen) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            }
            gl.uniform1i(gl.getUniformLocation(program, "u_image"), 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.uniform1i(gl.getUniformLocation(program, "u_text"), 1);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            gl.enableVertexAttribArray(texCoordLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform1f(gl.getUniformLocation(program, "u_time"), time * 0.001);
            gl.uniform1i(gl.getUniformLocation(program, "u_blueScreen"), vcrState.blueScreen ? 1 : 0);
            gl.uniform2f(gl.getUniformLocation(program, "u_resolution"), canvas.width, canvas.height);
            
            gl.uniform1f(gl.getUniformLocation(program, "u_noise"), parseFloat(params.noise));
            gl.uniform1f(gl.getUniformLocation(program, "u_scanline"), parseFloat(params.scanline));
            gl.uniform1f(gl.getUniformLocation(program, "u_rgbShift"), parseFloat(params.rgbShift));
            gl.uniform1f(gl.getUniformLocation(program, "u_distortion"), parseFloat(params.distortion));
            gl.uniform1f(gl.getUniformLocation(program, "u_wobble"), parseFloat(params.wobble));
            gl.uniform1f(gl.getUniformLocation(program, "u_hum"), parseFloat(params.hum));
            gl.uniform1f(gl.getUniformLocation(program, "u_vignette"), parseFloat(params.vignette));
            gl.uniform1f(gl.getUniformLocation(program, "u_sharpen"), parseFloat(params.sharpen));
            gl.uniform1f(gl.getUniformLocation(program, "u_brightness"), parseFloat(params.brightness));

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            updateTextCanvas();
            animationFrameId = requestAnimationFrame(render);
        }

        function setVCRState(status) {
            vcrState.status = status;
            document.querySelectorAll('.vcr-btn').forEach(b => b.classList.remove('active'));
            
            switch(status) {
                case "PLAY":
                    video.playbackRate = 1.0;
                    video.play();
                    vcrState.blueScreen = false;
                    document.getElementById('btn-play').classList.add('active');
                    break;
                case "PAUSE":
                    video.pause();
                    vcrState.blueScreen = false; 
                    document.getElementById('btn-pause').classList.add('active');
                    break;
                case "FF":
                    video.playbackRate = 3.0;
                    video.play();
                    vcrState.blueScreen = false;
                    document.getElementById('btn-ff').classList.add('active');
                    break;
                case "REW":
                    video.playbackRate = 1.0;
                    video.pause(); 
                    vcrState.blueScreen = false; 
                    document.getElementById('btn-rew').classList.add('active');
                    rewindInterval = setInterval(() => {
                        video.currentTime = Math.max(0, video.currentTime - 0.5);
                    }, 100);
                    return;
                case "STOP":
                    video.pause();
                    video.currentTime = 0;
                    vcrState.blueScreen = true;
                    break;
            }
            if (typeof rewindInterval !== 'undefined') clearInterval(rewindInterval);
        }
        let rewindInterval;

        function setupUI() {
            document.getElementById('btn-play').addEventListener('click', () => setVCRState("PLAY"));
            document.getElementById('btn-pause').addEventListener('click', () => setVCRState("PAUSE"));
            document.getElementById('btn-ff').addEventListener('click', () => setVCRState("FF"));
            document.getElementById('btn-rew').addEventListener('click', () => setVCRState("REW"));
            
            document.getElementById('toggle-vcr-osd').addEventListener('change', (e) => {
                vcrState.osdVisible = e.target.checked;
            });

            document.getElementById('video-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    loadVideoSource(url);
                }
            });

            document.getElementById('btn-camera').addEventListener('click', async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: 640, height: 480 },
                        audio: true 
                    });
                    video.srcObject = stream;
                    setVCRState("PLAY");
                    resizeCanvas();
                    placeholder.style.display = 'none';
                    canvas.classList.remove('hidden');
                } catch (err) {
                    alert("Ïπ¥Î©îÎùº Í∂åÌïú Ïò§Î•ò");
                }
            });

            const bindSlider = (id, key, displayId) => {
                const el = document.getElementById(id);
                // Fix: Check if element exists
                if (!el) {
                    return;
                }
                const display = document.getElementById(displayId || `val-${key}`);
                el.addEventListener('input', (e) => {
                    params[key] = e.target.value;
                    if(display) display.innerText = e.target.value;
                });
            };

            bindSlider('param-noise', 'noise');
            bindSlider('param-scanline', 'scanline'); 
            bindSlider('param-rgbShift', 'rgbShift');
            bindSlider('param-distortion', 'distortion');
            bindSlider('param-wobble', 'wobble');
            bindSlider('param-hum', 'hum');
            bindSlider('param-sharpen', 'sharpen');
            
            // GIF Duration Slider Logic
            const gifSlider = document.getElementById('param-gif-duration');
            const gifDisplay = document.getElementById('val-gif-duration');
            if (gifSlider) {
                gifSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    gifDuration = val * 1000;
                    gifDisplay.innerText = val.toFixed(1);
                });
            }

            document.getElementById('text-input').addEventListener('input', (e) => {
                textParams.customContent = e.target.value;
            });
            document.getElementById('text-x').addEventListener('input', (e) => {
                textParams.x = e.target.value;
            });
            document.getElementById('text-y').addEventListener('input', (e) => {
                textParams.y = e.target.value;
            });
        }

        function loadVideoSource(src) {
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(t => t.stop());
                video.srcObject = null;
            }
            video.src = src;
            video.load();
            setVCRState("PLAY");
            placeholder.style.display = 'none';
            canvas.classList.remove('hidden');
            resizeCanvas();
        }

        // Improved Download for Mobile
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        // Helper to check supported recording types
        function getSupportedMimeType() {
            const types = [
                'video/webm; codecs=vp9', 
                'video/webm; codecs=vp8', 
                'video/webm', 
                'video/mp4' // Newer iOS
            ];
            for (const type of types) {
                if (MediaRecorder.isTypeSupported(type)) {
                    return type;
                }
            }
            return ''; // Let browser pick default
        }

        const workerBlob = new Blob([`importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');`], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);
        
        document.getElementById('btn-record-gif').addEventListener('click', () => {
            const btn = document.getElementById('btn-record-gif');
            const indicator = document.getElementById('recording-indicator-gif');
            if (btn.disabled) return;
            btn.disabled = true;
            indicator.classList.remove('hidden');
            statusMsg.innerText = "GIF ÎÖπÌôî Ï§ë...";

            const gifWidth = 320;
            const gifHeight = Math.floor(gifWidth * (canvas.height / canvas.width));

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: gifWidth,
                height: gifHeight,
                workerScript: workerUrl
            });

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gifWidth;
            tempCanvas.height = gifHeight;
            const tempCtx = tempCanvas.getContext('2d');

            const fps = 15;
            // Use the dynamic duration
            const duration = gifDuration; 
            let framesCaptured = 0;
            const totalFrames = (duration / 1000) * fps;

            const interval = setInterval(() => {
                if (framesCaptured >= totalFrames) {
                    clearInterval(interval);
                    statusMsg.innerText = "GIF ÏÉùÏÑ± Ï§ë...";
                    gif.on('finished', (blob) => {
                        downloadBlob(blob, 'vcr_rec.gif');
                        btn.disabled = false;
                        indicator.classList.add('hidden');
                        statusMsg.innerText = "ÏôÑÎ£å!";
                    });
                    gif.render();
                } else {
                    tempCtx.drawImage(canvas, 0, 0, gifWidth, gifHeight);
                    gif.addFrame(tempCanvas, {copy: true, delay: 1000/fps});
                    framesCaptured++;
                }
            }, 1000/fps);
        });
        
        let mediaRecorder;
        let recordedChunks = [];
        let isVideoRecording = false;

        document.getElementById('btn-record-video').addEventListener('click', () => {
            const btn = document.getElementById('btn-record-video');
            const btnText = document.getElementById('video-btn-text');
            const indicator = document.getElementById('recording-indicator-video');

            if (!isVideoRecording) {
                const stream = canvas.captureStream(30); 
                let audioStream = null;
                if (video.srcObject) {
                    audioStream = video.srcObject;
                } else if (video.captureStream) {
                    audioStream = video.captureStream();
                } else if (video.mozCaptureStream) {
                    audioStream = video.mozCaptureStream();
                }

                if (audioStream && audioStream.getAudioTracks().length > 0) {
                    stream.addTrack(audioStream.getAudioTracks()[0]);
                }

                const mimeType = getSupportedMimeType();
                try {
                    mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
                } catch (e) {
                    console.error("MediaRecorder init failed, trying default", e);
                    mediaRecorder = new MediaRecorder(stream);
                }

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) recordedChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    // Default to .webm unless we know it's mp4, but webm is safer generic ext for web recording
                    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
                    // Simple logic to guess extension
                    const ext = (mediaRecorder.mimeType && mediaRecorder.mimeType.includes('mp4')) ? 'mp4' : 'webm';
                    downloadBlob(blob, `vcr_tape.${ext}`);
                    recordedChunks = [];
                    statusMsg.innerText = "ÎπÑÎîîÏò§ Ï†ÄÏû• ÏôÑÎ£å";
                };

                mediaRecorder.start();
                isVideoRecording = true;
                btn.classList.add('bg-red-900', 'text-white', 'border-red-500');
                btn.classList.remove('text-red-500');
                btnText.innerText = "‚ñ† Ï§ëÏßÄ";
                indicator.classList.remove('hidden');
                statusMsg.innerText = "ÎÖπÌôî Ï§ë...";

            } else {
                mediaRecorder.stop();
                isVideoRecording = false;
                btn.classList.remove('bg-red-900', 'text-white', 'border-red-500');
                btn.classList.add('text-red-500');
                btnText.innerText = "‚óè ÏòÅÏÉÅ Ï†ÄÏû•";
                indicator.classList.add('hidden');
            }
        });

        initWebGL();
        setupUI();
        requestAnimationFrame(render);
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
